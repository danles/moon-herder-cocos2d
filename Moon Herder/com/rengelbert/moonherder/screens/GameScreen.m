////  GameScreen.m//  MoonHerder////  Created by Roger Engelbert on 10/9/12.//  Copyright Done With Computers 2012. All rights reserved.//	#import "GameScreen.h"#import "Moon.h"#import "Sun.h"#import "MoonPerch.h"#import "Line.h"#import "PowerBar.h"#import "TimeBar.h"#import "LineContainer.h"#import "Star.h"#import "NumberSprite.h"#import "MoonHerderData.h"#import "MoonHerderGame.h"#import "MoonHerderSounds.h"#import "NSMutableArray+Shuffle.h"// GameScreen implementation@implementation GameScreen- (void) dealloc {        if (_drawLayer) [_drawLayer release];    [_moon release];	[_moonPerch release];	[_sun release];        [_boostHitParticles release];    [_lineHitParticles release];    [_groundHitParticles release];    [_starHitParticles release];        [_particlesLayer release];    	[super dealloc];}-(id) initWithGame:(Game *) game {		self = [super initWithGame:game];	if(self != nil) {		        _moonStartPoint = ccp(60 * game.screen_ratio, game.screenHeight - (60 * game.screen_ratio));                        _starsCollected = NO;		_sunRise = NO;		_run = NO;		_lines = [[NSMutableArray array] retain];                        //load particles        _boostHitParticles = [[CCParticleSystemQuad particleWithFile:@"boost_hit.plist"]retain];        _lineHitParticles = [[CCParticleSystemQuad particleWithFile:@"line_burst.plist"]retain];        _groundHitParticles = [[CCParticleSystemQuad particleWithFile:@"off_screen.plist"]retain];        _starHitParticles = [[CCParticleSystemQuad particleWithFile:@"star_burst.plist"]retain];                    [_boostHitParticles stopSystem];        [_lineHitParticles stopSystem];        [_groundHitParticles stopSystem];        [_starHitParticles stopSystem];                //scale particles if this is Ipad        _boostHitParticles.scale = _game.screen_ratio ;        _lineHitParticles.scale = _game.screen_ratio ;        _groundHitParticles.scale = _game.screen_ratio ;        _starHitParticles.scale = _game.screen_ratio ;                _gameState = GAME_STATE_PLAY;	}	return self;}-(void) create {	    [self newGame];		//if this is the first time creating this scene, well... create it!    if (_container == nil) {                [self initScreen];                [_container addChild:_bgDark];        //add lighter bg which is shown when Sun rises        [_container addChild:_bgLight];                [_container addChild:_sprites];        [_container addChild:_menu];        		[self addMoon];		[self addSun];        [self addBars];                //add ground        _ground = [_game.images getSkin:@"ground.png"];        [_ground setAnchorPoint:CGPointZero];        		//the draw layer for lines and bars        _drawLayer = [[[LineContainer alloc] initWithGame:_game withGameScreen:self] retain];                [_container addChild:_drawLayer];                _particlesLayer = [[[CCLayer alloc] init] retain];        [_particlesLayer addChild:_lineHitParticles];        [_particlesLayer addChild:_boostHitParticles];        [_particlesLayer addChild:_starHitParticles];        [_particlesLayer addChild:_groundHitParticles];                [_container addChild: _particlesLayer];                [_sprites addChild:_moon.skin z:Z_MOON];        [_sprites addChild:_sun.skin z:Z_SUN];        [_sprites addChild:_ground z:Z_GROUND];    	}		//this code needs to run to reset screen    [_lineHitParticles stopSystem];    [_boostHitParticles stopSystem];    [_starHitParticles stopSystem];    [_groundHitParticles stopSystem];        [self reset];	[self addStars];    if (!self.parent) [_game addChild:self];    _run = YES;    [_game.sounds play:SOUND_BACKGROUND];     _game.gameData.gameMode = GAME_MODE_PLAY;    }-(void) reset {        //reset sun    [_sun placeAtX:_game.screenWidth * 0.5 atY: -_sun.radius];    _sun.skin.visible = NO;    [_sun reset];    	//reset bars    [_timeBar reset];    [_powerBar reset];		//reset moon and perch    [_moon placeAtX:_moonStartPoint.x atY:_moonStartPoint.y];    [_moon reset];    _moonPerch.skin.opacity = 50;	//clear lines    [_drawLayer clear];		//clear all visible stars	[self clearAllStars];	_starsCollected = NO;        _startPoint = CGPointZero;    _touchPoint = CGPointZero;        _bgDark.opacity = 255;    _bgLight.opacity = 0;        _starsUpdateIndex = 0;    _starsUpdateRange = 10;    _starsUpdateInterval = 5;    _starsUpdateTimer = 0.0;        _gameState = GAME_STATE_PLAY;}-(void) destroy  {    [_game.sounds stopBGMusic];	[self reset];    [super destroy];}//show NEW level message-(void) newLevel {    //clear any remaining lines currently on stage    if (_lines.count > 0) {        [_lines removeAllObjects];    }        _game.gameData.gameMode = GAME_MODE_MENU;    _gameState = GAME_STATE_NEW_LEVEL;        _game.gameData.level++;    [_game.gameData update];        //add new level message screen elements    CCSprite * pound = [_game.images getSkin:@"label_number.png"];    [pound setPosition:ccp(_game.screenWidth * 0.42, _game.screenHeight * 0.65)];    [_menu addChild:pound];        //level number    NumberSprite * level = [[[NumberSprite alloc] initWithGame:_game withBatch:_menu at:ccp(pound.position.x + pound.textureRect.size.width, pound.position.y) withFrameName:@"numbers_large_"] autorelease];    [level showValue:_game.gameData.level];        CCSprite * meridian = [_game.images getSkin:@"label_meridian.png"];    [meridian setPosition:ccp(_game.screenWidth * 0.5f, level.y - level.height * 1.2f - meridian.textureRect.size.height * 0.5f)];    [_menu addChild:meridian];        int total_score = [_game.gameData getValue:TOTAL_STARS_COLLECTED];        CCSprite * score = [_game.images getSkin:@"label_score.png"];    [score setPosition:ccp(meridian.position.x - meridian.textureRect.size.width * 0.5f + score.textureRect.size.width * 0.5f,                           meridian.position.y - meridian.textureRect.size.height * 0.5f - score.textureRect.size.height * 1.2f)];    [_menu addChild:score];            NumberSprite * number = [[[NumberSprite alloc] initWithGame:_game withBatch:_menu at:ccp(score.position.x + score.textureRect.size.width * 0.68f, score.position.y) withFrameName:@"numbers_small_"] autorelease];            [number showValue:total_score];        CCSprite * stars = [_game.images getSkin:@"label_stars.png"];    [stars setPosition:ccp(number.x + number.width * 1.2f + stars.textureRect.size.width * 0.5f, number.y)];    [_menu addChild:stars];        CCSprite *best;    //if stars collected since start of game greater than highest score, show new best score   if (total_score > [_game.gameData getValue:BEST_SCORE]) {        [_game.gameData setValue:BEST_SCORE withInt:total_score];       best = [_game.images getSkin:@"label_best_score.png"];       [best setPosition:ccp(_game.screenWidth * 0.5f ,number.y - number.height * 1.2 - best.textureRect.size.height * 0.5)];       [_menu addChild:best];        //show current score and highest score    } else {        if ([_game.gameData getValue:BEST_SCORE] > 1) {            [self displayScoresAtX:score.position.x - score.textureRect.size.width * 0.5f atY:score.position.y - score.textureRect.size.height * 1.2 - score.textureRect.size.height * 0.5];        }    }        CCSprite * start = [_game.images getSkin:@"label_start.png"];    [start setPosition:ccp(_game.screenWidth * 0.5f, _game.screenHeight * 0.2f)];    [_menu addChild:start];        if (_menu.parent == nil) [_container addChild:_menu];}//show game over message-(void) gameOver {        //remove any remaining lines    if (_lines.count > 0) {        [_lines removeAllObjects];    }        _game.gameData.gameMode = GAME_MODE_MENU;    _gameState = GAME_STATE_GAME_OVER;        //********* GAME OVER SCREEN ******************        //add game over    CCSprite * logo = [_game.images getSkin:@"label_game_over.png"];    [logo setPosition:ccp(_game.screenWidth * 0.5, _game.screenHeight * 0.65)];    [_menu addChild:logo];        CCSprite * score = [_game.images getSkin:@"label_score.png"];    [score setPosition:ccp(logo.position.x - logo.textureRect.size.width * 0.5f + score.textureRect.size.width * 0.5f,                           logo.position.y - logo.textureRect.size.height * 0.5f - score.textureRect.size.height)];    [_menu addChild:score];        NumberSprite * number = [[[NumberSprite alloc] initWithGame:_game withBatch:_menu at:ccp(score.position.x + score.textureRect.size.width * 0.68f, score.position.y) withFrameName:@"numbers_small_"] autorelease];        int total_score = [_game.gameData getValue:TOTAL_STARS_COLLECTED];    [number showValue:total_score];        CCSprite * stars = [_game.images getSkin:@"label_stars.png"];    [stars setPosition:ccp(number.x + number.width * 1.2 + stars.textureRect.size.width * 0.5f, number.y)];    [_menu addChild:stars];        CCSprite * best;   	   	//show new best score if a new one was set, or current score and best score    if (total_score > [_game.gameData getValue:BEST_SCORE]) {        best = [_game.images getSkin:@"label_best_score.png"];        [best setPosition:ccp(_game.screenWidth * 0.5f ,number.y - number.height * 1.2 - best.textureRect.size.height * 0.5)];        [_menu addChild:best];        [_game.gameData setValue:BEST_SCORE withInt:total_score];    } else {                if ([_game.gameData getValue:BEST_SCORE] > 1) {            [self displayScoresAtX:score.position.x - score.textureRect.size.width * 0.5f atY:score.position.y - score.textureRect.size.height * 1.2 - score.textureRect.size.height * 0.5];               }    }    //add buttons    CCSprite * try = [_game.images getSkin:@"label_try_again.png"];    [try setPosition:ccp(_game.screenWidth * 0.5, _game.screenHeight * 0.26)];    _tryAgainBounds = try.boundingBox;    [_menu addChild:try];        CCSprite * menuLabel = [_game.images getSkin:@"label_menu.png"];    [menuLabel setPosition:ccp(_game.screenWidth * 0.5, try.position.y - try.textureRect.size.height * 2)];    _menuBounds = menuLabel.boundingBox;    [_menu addChild:menuLabel];            if (_menu.parent == nil) [_container addChild:_menu];        }-(void) newGame {	[_game.gameData reset];}-(void) update:(float) dt {        if (_game.gameData.gameMode == GAME_MODE_PLAY) {							//if running game logic		if (_run) {                        dt *= _gameRate;				//update elements			[_moon update:dt];				if (_sun.skin.visible) {				[_sun update: dt];                if ([_sun checkCollisionWithMoon:_moon]) {                    [_game.sounds play:SOUND_SUN_HIT];                }			}				//check collision with lines, update, draw			Line * line;            int len = _lines.count;            int i;            BOOL collisionDetected = NO;						for (i = len-1; i >= 0; i--) {					line = [_lines objectAtIndex:i];                				if (!collisionDetected && line.active) {					if ([line collidesWithBall:_moon]) {						collisionDetected = YES;                        [_game.sounds play:SOUND_LINE_HIT];                        [_lineHitParticles setPosition:line.collisionPoint];                        [_lineHitParticles resetSystem];					}				}					if (line.trashMe) {                    [_lines removeObjectAtIndex:i];				} else {                    [line update:dt];                }			}                        			[_moon place];                        //if moon off screen to the top, make screen darker as moons gets farther and farther away            if (_moon.skin.position.y > _game.screenHeight) {                if (!_sun.skin.visible) {                    float opacity = fabs((255 * (_moon.skin.position.y - _game.screenHeight))/_game.screenHeight);                    if (opacity > 200) opacity = 200;                    _bgDark.opacity = 255 - opacity;                }            } else {                if (_bgDark.opacity != 255) _bgDark.opacity = 255;            }            			if (_sun.skin.visible) {                //when sun is added to screen, fade out dark bg                 if (_bgLight.opacity + 5  < 255) {                    _bgLight.opacity += 5;                    _bgDark.opacity -= 5;                }                                 				[_sun place];			}				//track collision with MOON and STAR (usign grid logic)            float range = _moon.radius;            float posX = _moon.skin.position.x;            float posY = _moon.skin.position.y;            			//I decided to check 9 cells            [self clearStarAtX:posX atY:posY];            [self clearStarAtX:posX atY:posY + range];            [self clearStarAtX:posX atY:posY - range];            [self clearStarAtX:posX + range atY:posY];            [self clearStarAtX:posX + range atY:posY + range];            [self clearStarAtX:posX + range atY:posY - range];            [self clearStarAtX:posX - range atY:posY];            [self clearStarAtX:posX - range atY:posY - range];            [self clearStarAtX:posX - range atY:posY + range];                        //update bars            [_timeBar update:dt];            [_powerBar update:dt];            			//check timer			if ([_timeBar getPercentage] <= 0.65f && !_sun.skin.visible) {				[_game.sounds play:SOUND_SUN_RISE];                _sun.skin.visible = YES;				_sun.hasRisen = NO;			} else if ([_timeBar getPercentage] <= 0.1f && _sun.skin.visible && !_sun.hasGrown) {                [_game.sounds play:SOUND_SUN_GROW];                [_sun highNoon];            } else if ([_timeBar getPercentage] <= 0.0f) {                //if you want game over once time runs out.                 //[self gameOver];            }                        //check power            if ([_powerBar getPercentage] <= 0) {                if (!_moon.off) {                    [_moon turnOnOff:NO];                }            }						//track collision between Moon and Moon's perch			if (_starsCollected) {                if ((_moonStartPoint.x - _moon.skin.position.x) * (_moonStartPoint.x - _moon.skin.position.x) + (_moonStartPoint.y - _moon.skin.position.y) * (_moonStartPoint.y - _moon.skin.position.y) < _moon.squaredRadius) {					[_moon.skin setPosition:_moonStartPoint];										[self newLevel];									}			}                        if (_moon.skin.position.y < _moon.radius && _moon.active) {                [_groundHitParticles setPosition:_moon.skin.position];                [_groundHitParticles resetSystem];                [_game.sounds play:SOUND_GROUND_HIT];                _moon.active = NO;                [self gameOver];            }                        //make stars blink            if (!_sun.skin.visible) {                _starsUpdateTimer += dt;                int stars_count = [MoonHerderScreen stars].count;                if (_starsUpdateTimer > _starsUpdateInterval) {                                        if (stars_count - _starsUpdateIndex < _starsUpdateRange) {                        _starsUpdateIndex = 0;                    } else if (_starsUpdateIndex + _starsUpdateRange > stars_count - 1) {                        _starsUpdateIndex += stars_count - _starsUpdateIndex - 1;                    } else {                        _starsUpdateIndex += _starsUpdateRange;                    }                                        _starsUpdateTimer = 0;                    _starsUpdateInterval = ((float)rand() / RAND_MAX) * 5;                }                                //update stars within update range                Star * star;                for (int i = _starsUpdateIndex; i < _starsUpdateIndex + _starsUpdateRange; i++) {                    if (i < stars_count) {                        star = [[MoonHerderScreen stars] objectAtIndex:i];                        if (star.skin.visible && !star.boost) [star update:dt];                    }                                    }            }		}	}}-(void) processTouchBegin:(CGPoint) touch {	    if (_game.gameData.gameMode == GAME_MODE_PLAY) {		_startPoint = touch;        _touchPoint = CGPointZero;	}}-(void) processTouchEnd:(CGPoint) touch {            if (_game.gameData.gameMode == GAME_MODE_PLAY) {                //don't bother creating new lines if 10 on stage already, or if no power        if ([_lines count] > 10 || [_powerBar getPercentage] <= 0) {            _startPoint = CGPointZero;            _touchPoint = CGPointZero;            return;        }                //don't bother with line if points aren't set on screen        //and if start and end points are the same        if (!CGPointEqualToPoint(_startPoint, CGPointZero) &&        	!CGPointEqualToPoint(_startPoint, touch)) {                        //grab a line from the pool            Line * line = (Line *) [_game getObjectFromPoolWithName:POOL_LINES];                        [line setValues:_startPoint endPoint:touch];                        //check length of the line, if too short, get rid of it            if (line.length < 40 * _game.screen_ratio) {                _startPoint = CGPointZero;                _touchPoint = CGPointZero;                return;            }                        [_lines addObject:line];                        //if we are boosting power, a new line means no more boosting            if (_powerBar.boosting) {                _powerBar.boosting = NO;                _moon.blinking = NO;                //turn moon ON if we still have power, OFF if not                [_moon turnOnOff:([_powerBar getPercentage] > 0)];            }                        //calculate the energy cost of the created line            float cost = line.length * [_game.gameData getFloatValue:LINE_DECREMENT];           	           	//if more than one line on screen, then add that to the cost            if (_lines.count > 1) cost *= _lines.count;                        [_powerBar changeBy:-cost];                    }        _touchPoint = CGPointZero;        _startPoint = CGPointZero;            } else if (_game.gameData.gameMode == GAME_MODE_MENU) {                        //if showing New Level message, with TOUCH END, start new level        if (_gameState == GAME_STATE_NEW_LEVEL) {                        [_menu removeAllChildrenWithCleanup:YES];                        _game.gameData.gameMode = GAME_MODE_PLAY;                                    [self reset];            [self addStars];                //if showing Game Over message, with TOUCH END, track buttons        } else {	        //pressed try again button            if (CGRectContainsPoint(_tryAgainBounds, touch)) {                                [_menu removeAllChildrenWithCleanup:YES];                                [_game.gameData reset];                [self reset];                [self addStars];                                _game.gameData.gameMode = GAME_MODE_PLAY;             //pressed  main menu button            } else if (CGRectContainsPoint(_menuBounds, touch)){                [_menu removeAllChildrenWithCleanup:YES];                                [_game setScreenWithName:@"IntroScreen"];            }                    }    }}-(void) processTouchMove:(CGPoint) touch {    if (_game.gameData.gameMode == GAME_MODE_PLAY) {        _touchPoint = touch;    }}-(void) addMoon {       _moonPerch = [[[MoonPerch alloc] initWithGame:_game andPosition:_moonStartPoint] retain];    [_sprites addChild: _moonPerch.skin];           _moon = [[[Moon alloc] initWithGame:_game withRadius:16] retain];}-(void) addStars {            [[MoonHerderScreen gridCells] shuffle];        Star * star;        //number of stars and boosts to add to this level    _numStars = [_game.gameData getValue:TOTAL_STARS];    int numBoosts = [_game.gameData getValue:BOOSTS];    NSValue * value;    int i = 0;    int cnt = 0;    int index;    CGPoint position;        while (cnt < _numStars) {        value = [[MoonHerderScreen gridCells] objectAtIndex:i];        [value getValue:&position];        i++;                //grab stars array index based on selected Grid Cell        index = position.y * _cols + position.x;                //grab position from selected Grid Cell        position.x = position.x * _tile_size;        position.y = _game.screenHeight - position.y * _tile_size;                //don't use cells too close to moon perch        if (fabs(position.x  - _moonStartPoint.x) < _moon.radius * 2 &&        fabs(position.y - _moonStartPoint.y) < _moon.radius * 2) {            continue;        }                //grab star from pool        star = (Star *) [_game getObjectFromPoolWithName:POOL_STARS];                //add boosts first, if any         if ( cnt >= _numStars - numBoosts) {            [star setValues:position.x                       posY:position.y                      range:_tile_size isBoost:YES];                    } else {            [star setValues:position.x                       posY:position.y                      range:_tile_size isBoost:NO];        }                [[MoonHerderScreen stars] replaceObjectAtIndex:index withObject:star];        if (!star.skin.parent) [_sprites addChild:star.skin z:Z_STARS];                cnt++;    }}-(void) addSun {    _sun = [[[Sun alloc] initWithGame:_game] retain];}-(void) addBars {        _powerBar = [[[PowerBar alloc] initWithGame:_game withWidth:1 withHeight:_game.screenHeight * 0.8f] retain];    _timeBar = [[[TimeBar alloc] initWithGame:_game withWidth:_game.screenWidth * 0.8f withHeight:1] retain];}-(void) clearStarAtX:(float) x atY:(float) y {	    int col = x / _tile_size;	int row  = (_game.screenHeight - y) / _tile_size;	if (row < 0 || col < 0 || row >= _rows || col >= _cols || [MoonHerderScreen stars].count < row * _cols + col) {		return;	}	//identify cell in array	Star * s = [[MoonHerderScreen stars] objectAtIndex:row * _cols + col];	        if (s.skin != nil && s.skin.visible == YES) {                       float diffx = _moon.skin.position.x - s.skin.position.x;        float diffy = _moon.skin.position.y - s.skin.position.y;                if ((diffx * diffx + diffy * diffy) <= _moon.squaredRadius) {                        int starsCollected = [_game.gameData getValue:COLLECTED_STARS];            int totalStarsCollected = [_game.gameData getValue:TOTAL_STARS_COLLECTED];                        starsCollected++;            totalStarsCollected++;                        [_game.gameData setValue:COLLECTED_STARS withInt:starsCollected];            [_game.gameData setValue:TOTAL_STARS_COLLECTED withInt:totalStarsCollected];                                    s.skin.visible = NO;                                    int totalStars = [_game.gameData getValue:TOTAL_STARS];            //did we hit a boost?            if (s.boost) {                            //if we hit a power boost while boosting, increase boost speed                if (_powerBar.boosting) _powerBar.boosting++;                                _powerBar.boosting = YES;                                _moon.blinking = YES;                if (starsCollected != totalStars) {                    [_boostHitParticles setPosition:s.skin.position];                    [_boostHitParticles resetSystem];                }            }                        //if last star on screen, show particles, show Moon Perch...            if (starsCollected == totalStars) {                [_game.sounds play:SOUND_LAST_STAR_HIT];                [_starHitParticles setPosition:s.skin.position];                [_starHitParticles resetSystem];                _starsCollected = YES;                if (_sun.skin.visible) {                    _moonPerch.skin.opacity = 150;                } else {                    _moonPerch.skin.opacity = 200;                }            } else {                if (s.boost) {                    [_game.sounds play:SOUND_BOOST_HIT];                } else {                    [_game.sounds play:SOUND_STAR_HIT];                }            }                     }	}    }//helper method to display best score at both New Level and Game Over messages-(void) displayScoresAtX:(float) x atY:(float) y {        CCSprite * best = [_game.images getSkin:@"label_best.png"];    [best setPosition:ccp(x + best.textureRect.size.width * 0.5f, y)];        NumberSprite * best_score = [[[NumberSprite alloc] initWithGame:_game withBatch:_menu at:ccp(best.position.x + best.textureRect.size.width * 0.6f, best.position.y) withFrameName:@"numbers_small_"] autorelease];    [best_score showValue:[_game.gameData getValue:BEST_SCORE]];        CCSprite * stars = [_game.images getSkin:@"label_stars.png"];    [stars setPosition:ccp(best_score.x + best_score.width * 1.2 + stars.textureRect.size.width * 0.5f, best_score.y)];        [_menu addChild:stars];    [_menu addChild:best];}@end