////  Star.m//  MoonHerder////  Created by Roger Engelbert on 10/9/12.//  Copyright Done With Computers 2012. All rights reserved.//	#import "Star.h"static int *TYPES;static int TYPE_INDEX = 0;// Star implementation@implementation Star@synthesize size = _size, boost = _boost;- (void) dealloc {	    if (TYPES != NULL) {        free (TYPES);        TYPES = NULL;    }	    [super dealloc];}-(id) initWithGame:(Game *) game {	self = [super initWithGame:game];	if(self != nil) {		//when variation is more important than randomness... 		if (TYPES == NULL) {            //these are star types... shuffling these values is not required as            //grid cells are shuffled every time a new level begins            //I only need these values to be "slightly"out of order            TYPES = malloc( 16 * sizeof(int));            TYPES[0] = 0;            TYPES[1] = 1;            TYPES[2] = 2;            TYPES[3] = 3;            TYPES[4] = 0;            TYPES[5] = 2;            TYPES[6] = 3;            TYPES[7] = 1;            TYPES[8] = 1;            TYPES[9] = 3;            TYPES[10] = 2;            TYPES[11] = 0;            TYPES[12] = 0;            TYPES[13] = 2;            TYPES[14] = 1;            TYPES[15] = 3;        }                _skin = nil;	}		return self;}-(void) setValues:(float) x posY:(float) y range:(int) r isBoost:(BOOL) boost {	    _boost = boost;       	if (boost) {        _skin = [[_game.images getSkin:@"boost.png"] retain];        	} else {		int index = TYPES[TYPE_INDEX];                switch (index) {			case STAR_SIZE_1:                _frame1 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_1.png"];                _frame2 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_1_off.png"];				                _size = 4 * _game.screen_ratio;			break;			case STAR_SIZE_2:                _frame1 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_2.png"];                _frame2 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_2_off.png"];                                                _size = 6 * _game.screen_ratio;			break;			case STAR_SIZE_3:                _frame1 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_3.png"];                _frame2 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_3_off.png"];                                                _size = 8 * _game.screen_ratio;			break;			case STAR_SIZE_4:                _frame1 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_4.png"];                _frame2 = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"star_4_off.png"];                                                _size = 10 * _game.screen_ratio;			break;		}        int r = floor(((float) rand() / RAND_MAX) * 10);        if (r > 5) {            _skin = [CCSprite spriteWithSpriteFrame:_frame1];            _frame = 1;        } else {            _skin = [CCSprite spriteWithSpriteFrame:_frame2];            _frame = 2;        }  	}		float random_range = arc4random() % 2;		//offset the stars a bit, so as to get rid of the "Grid Cell" look    [self placeAtX:x + random_range * r * 0.5 atY:y + random_range * r * 0.5];		//if too close to the sides, move stars a bit	if (_skin.position.x < 10) [self placeAtX: 10];    	if (_skin.position.x > _game.screenWidth - 16 * _game.screen_ratio)        [self placeAtX:_game.screenWidth - 16 * _game.screen_ratio];		//if too close to the top, same thing    if (_skin.position.y > _game.screenHeight - 10 * _game.screen_ratio)        [self placeAtY: _game.screenHeight - 10 * _game.screen_ratio];		TYPE_INDEX += 1;	if (TYPE_INDEX == 16) TYPE_INDEX = 0;		_skin.visible = YES;	    _blinkTimer = 0.0;    _blinkInterval = ((float)rand() / RAND_MAX) * 3 + 1;    }-(void) update:(float)dt {        _blinkTimer += dt;    //change image used, and change opacity when animated    if (_blinkTimer > _blinkInterval && !_boost) {        _blinkTimer = 0.0;                if (_frame == 1 ) {            _frame = 2;             [_skin setDisplayFrame:_frame2];        } else  {            _frame = 1;            [_skin setDisplayFrame:_frame1];        }        _skin.opacity = _skin.opacity == 180 ? 255 : 180;        _skin.rotation += 20;    }    }@end			