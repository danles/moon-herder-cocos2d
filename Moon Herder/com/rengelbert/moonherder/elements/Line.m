////  Line.m//  MoonHerder////  Created by Roger Engelbert on 10/9/12.//  Copyright Done With Computers 2012. All rights reserved.//	#import "Line.h"// Line implementation@implementation Line@synthesize length = _length, start = _start, end = _end, blinkState = _blinkState, curveState = _curveState, curve = _curve,  collisionPoint = _collisionPoint;- (void) dealloc {		[super dealloc];}-(id) initWithGame:(Game *) game {	self = [super initWithGame:game];	if(self != nil) {		_skin = nil;        _bounce = BOUNCE;        if (_game.screen_ratio == 2) _bounce *= 0.5f;	}		return self;}-(void) setValues:(CGPoint) start endPoint:(CGPoint) end {		if (start.x <= end.x) {		_start = start;		_end = end;	} else {		_start = end;		_end = start;	}		_curve = CGPointZero;				_active = YES;	_trashMe = NO;	_hit = NO;		//these are used as timers for blinking time, active time, curve animation	_blinkInterval = 0;	_activeInterval = 0;	_curveInterval = 0;	_blinking = false;	_blinkState = 0;	_curveState = 0;	[self calculateLineData];}-(void) update:(float) dt {	if (!_active || _trashMe) return;	        //count active time	_activeInterval += dt;	if (_hit) {		//animate curve if line is hit		_curveInterval += dt;		if (_curveInterval > CURVE_INTERVAL) {			_curveInterval = 0;			_curveState = (_curveState == 0) ? 1 : 0;		}			} else {		//if not hit, and at 75% active time, start blinking the line		if (_activeInterval > TIME_ACTIVE * 0.75f) {           _blinking = true;		}	}		//destroy line if past its active time	if (_activeInterval > TIME_ACTIVE) {		_active = NO;		_trashMe = YES;		[self destroy];		return;	}		if (_blinking) {		_blinkInterval += dt;		//blink		if (_blinkInterval > BLINK_INTERVAL) {            _blinkInterval = 0;			_blinkState = (_blinkState == 0) ? 1 : 0;		}			}}-(BOOL) collidesWithBall:(Ball *) ball {	//line can only collide once	if (_hit)	{		return NO;	}		//if within range of line segment	float r = [self rangeWithBall:ball];		if (r < 0 || r > 1)  return NO;		CGPoint normal = [self getNormalForBall:ball];	float t = [self ballProjectionOfBall:ball onNormal:normal];		if (t > 0 && t < 1) {                //get ball's vector        float ballDiffX = ball.nextX - ball.skin.position.x;		float ballDiffY = ball.nextY - ball.skin.position.y;                if (ballDiffX * normal.x + ballDiffY * normal.y > 0) return NO;        		//collision!!!!		_hit = YES;		_blinking = true;		if (_activeInterval < TIME_ACTIVE * TIME_CURVING) _activeInterval = TIME_ACTIVE * TIME_CURVING;		        ball.vx = _bounce * _length * normal.x;		ball.vy = _bounce * _length * normal.y;				_collisionPoint = ccp(ball.skin.position.x + t * ballDiffX,											 ball.skin.position.y + t * ballDiffY);		_curve = _collisionPoint;				_curve.x -= CURVE_AMOUNT * _game.screen_ratio * normal.x;		_curve.y -= CURVE_AMOUNT * _game.screen_ratio * normal.y;    		_curveState = 1;		return YES;	}		return NO;}-(float) rangeWithBall:(Ball *) ball {	float ballToStartX = ball.skin.position.x - _start.x;	float ballToStartY = ball.skin.position.y - _start.y;					//get dot product of this line's vector and ballToStart vector	float dot = ballToStartX * _vectorX + ballToStartY * _vectorY;	//solve it to the segment	return dot/_lenSquared;;}-(CGPoint) getNormalForBall:(Ball *) ball {	float lineStartToBallX = ball.skin.position.x - _start.x;	float lineStartToBallY = ball.skin.position.y - _start.y;		//check dot product value to grab correct normal	float leftNormal = lineStartToBallX * _normalLeft.x + lineStartToBallY * _normalLeft.y;	CGPoint normal;		if (leftNormal > 0) {		normal = _normalLeft;	} else {		normal = _normalRight;	}	return normal;}-(float) ballProjectionOfBall:(Ball *) ball onNormal:(CGPoint) normal {		float lineStartToBallNowX = ball.skin.position.x - _start.x;	float lineStartToBallNowY = ball.skin.position.y - _start.y;		float lineStartToBallNextX = ball.nextX - _start.x;	float lineStartToBallNextY = ball.nextY - _start.y;		//check dot product value to grab correct normal	float distanceToLineNow = lineStartToBallNowX * normal.x + lineStartToBallNowY * normal.y;	float distanceToLineNext = lineStartToBallNextX * normal.x + lineStartToBallNextY * normal.y;		return (ball.radius - distanceToLineNow) / (distanceToLineNext - distanceToLineNow);	}-(void) calculateLineData {	    _length = ccpDistance(_start,_end);    //line vector    _vectorX = _end.x - _start.x;	_vectorY = _end.y - _start.y;	//squared length	_lenSquared = _vectorX * _vectorX + _vectorY * _vectorY;		//_normalAngle = atan2(_vectorY, -_vectorX);    //_normalCos = cosf(_normalAngle);    //_normalSin = sinf(_normalAngle);		float normalX = _vectorY;	float normalY = -_vectorX;		float normalLength = sqrt(normalX * normalX + normalY * normalY);	//normalized normals	_normalLeft = ccp(normalX / normalLength, normalY / normalLength);	_normalRight = ccp( -1*_normalLeft.x, -1*_normalLeft.y); 	}@end