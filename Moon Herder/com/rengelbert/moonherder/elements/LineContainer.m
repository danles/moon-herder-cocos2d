////  LineContainer.m//  MoonHerder////  Created by Roger Engelbert on 10/9/12.//  Copyright Done With Computers 2012. All rights reserved.//	#import "LineContainer.h"#import "MoonHerderScreen.h"/*Layer for Primitives drawingHere I draw the lines created by the player as well as the bars (time, power)*/// LineContainer implementation@implementation LineContainer- (void) dealloc {		[super dealloc];}-(id) initWithGame:(Game *) game withGameScreen:(MoonHerderScreen *) screen {	self = [super init];	if( self != nil) {                _game = game;        _screen = screen;        _lines = screen.lines;		_powerBar = screen.powerBar;        _timeBar = screen.timeBar;                _line_thickness = 6 * game.screen_ratio;        _bar_thickness = 2 * game.screen_ratio;                glLineWidth(_line_thickness);        glEnable(GL_LINE_SMOOTH);        	}		return self;} -(void) clear {    [super draw];}-(void) draw {        [super draw];                glLineWidth(_bar_thickness);    glEnable(GL_LINE_SMOOTH);        [self drawBar:_timeBar];    [self drawBar:_powerBar];            glLineWidth(_line_thickness);    //draw temp line if any    if (!CGPointEqualToPoint(_screen.startPoint, CGPointZero)) {        glColor4f(0.0, 0.0, 0.0, 1.0);                ccDrawCircle(_screen.startPoint, 5 * _game.screen_ratio, CC_DEGREES_TO_RADIANS(360), 10, NO);                if (!CGPointEqualToPoint(_screen.touchPoint, CGPointZero)) {                       ccDrawCircle(_screen.touchPoint, 5 * _game.screen_ratio, CC_DEGREES_TO_RADIANS(360), 10, NO);                        ccDrawLine(_screen.startPoint, _screen.touchPoint);                    }                }        int numLines = _lines.count;    Line * line;    for (int i = numLines - 1; i >= 0; i--) {        line = [_lines objectAtIndex:i];        [self drawLine:line];    }}-(void) drawBar:(Bar *) bar {        if (bar.orientation == HORIZONTAL) {                if (bar.width == 0) return;                if (bar.width != bar.totalWidth) {            glColor4f(0.0, 0.0, 0.0, 1.0);            ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x + bar.totalWidth, bar.y));        }                glColor4f(0.0, 1.0, 1.0, 1.0);        ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x + bar.width, bar.y));            } else {                if (bar.height != bar.totalHeight) {            if (bar.blinkState == 0) {                glColor4f(0.0, 0.0, 0.0, 1.0);            } else {                glColor4f(1.0, 0.0, 0.0, 1.0);            }            ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x, bar.y + bar.totalHeight));        }                if (bar.height == 0) return;        if (bar.boosting) {            if (bar.blinkState == 0) {                glColor4f(1.0, 0.9, 0.0, 1.0);            } else {                glColor4f(1.0, 0.0, 1.0, 1.0);            }        } else {            glColor4f(1.0, 0.9, 0.0, 1.0);        }                        ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x, bar.y + bar.height));    }}-(void) drawLine:(Line *) line {        if (line.blinkState == 0) {        glColor4f(1.0, 0.0, 1.0, 1.0);    } else {        glColor4f(1.0, 1.0, 1.0, 1.0);    }        //draw curved line    if (line.curveState != 0 && !CGPointEqualToPoint(line.curve, CGPointZero)) {        ccDrawQuadBezier(line.start, line.curve, line.end, 10);            //draw straight line    } else {        NSLog (@"LINE START X Y: %f  %f", line.start.x, line.start.y);        ccDrawLine(line.start, line.end);    }}@end