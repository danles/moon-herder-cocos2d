////  LineContainer.m//  MoonHerder////  Created by Roger Engelbert on 10/9/12.//  Copyright Done With Computers 2012. All rights reserved.//	#import "LineContainer.h"#import "MoonHerderScreen.h"/*Layer for Primitives drawingHere I draw the lines created by the player as well as the bars (time, power)*/// LineContainer implementation@implementation LineContainer- (void) dealloc {		[super dealloc];}-(id) initWithGame:(Game *) game withGameScreen:(MoonHerderScreen *) screen {	self = [super init];	if( self != nil) {                _game = game;        _screen = screen;        _lines = screen.lines;		_powerBar = screen.powerBar;        _timeBar = screen.timeBar;                _line_thickness = 6 * game.screen_ratio;        _bar_thickness = 2 * game.screen_ratio;                glLineWidth(_line_thickness);        glEnable(GL_LINE_SMOOTH);        	}		return self;} -(void) clear {    [super draw];}-(void) draw {        [super draw];                glLineWidth(_bar_thickness);    glEnable(GL_LINE_SMOOTH);        [self drawBar:_timeBar];    [self drawBar:_powerBar];            glLineWidth(_line_thickness);    //draw temp line if any    if (!CGPointEqualToPoint(_screen.startPoint, CGPointZero)) {        glColor4f(0.0, 0.0, 0.0, 1.0);                ccDrawCircle(_screen.startPoint, 5 * _game.screen_ratio, CC_DEGREES_TO_RADIANS(360), 10, NO);                if (!CGPointEqualToPoint(_screen.touchPoint, CGPointZero)) {                       ccDrawCircle(_screen.touchPoint, 5 * _game.screen_ratio, CC_DEGREES_TO_RADIANS(360), 10, NO);                        ccDrawLine(_screen.startPoint, _screen.touchPoint);                    }                }        int numLines = _lines.count;    Line * line;    for (int i = numLines - 1; i >= 0; i--) {        line = [_lines objectAtIndex:i];        [self drawLine:line];    }}-(void) drawBar:(Bar *) bar {        if (bar.orientation == HORIZONTAL) {                if (bar.width == 0) return;                if (bar.width != bar.totalWidth) {            glColor4f(0.0, 0.0, 0.0, 1.0);            ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x + bar.totalWidth, bar.y));        }                glColor4f(0.0, 1.0, 1.0, 1.0);        ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x + bar.width, bar.y));            } else {                if (bar.height != bar.totalHeight) {            if (bar.blinkState == 0) {                glColor4f(0.0, 0.0, 0.0, 1.0);            } else {                glColor4f(1.0, 0.0, 0.0, 1.0);            }            ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x, bar.y + bar.totalHeight));        }                if (bar.height == 0) return;        if (bar.boosting) {            if (bar.blinkState == 0) {                glColor4f(1.0, 0.9, 0.0, 1.0);            } else {                glColor4f(1.0, 0.0, 1.0, 1.0);            }        } else {            glColor4f(1.0, 0.9, 0.0, 1.0);        }                        ccDrawLine(ccp(bar.x, bar.y), ccp(bar.x, bar.y + bar.height));    }}-(void) drawLine:(Line *) line {        if (line.blinkState == 0) {        glColor4f(1.0, 0.0, 1.0, 1.0);    } else {        glColor4f(1.0, 1.0, 1.0, 1.0);    }        //draw curved line    if (line.curveState != 0 && !CGPointEqualToPoint(line.curve, CGPointZero)) {        [self drawQuadBezier:line.start control:line.curve destination:line.end  segments:10];            //draw straight line    } else {        ccDrawLine(line.start, line.end);    }}-(void) drawQuadBezier:(CGPoint) origin control:(CGPoint) control destination:(CGPoint) destination  segments:(NSUInteger) segments {	        float t = 0.0f;    float x_;    float y_;        CGPoint previous = origin;    for (int i = 0; i < segments + 1; i++) {                x_ = powf(1 - t, 2) * origin.x + 2.0f * (1 - t) * t * control.x + t * t * destination.x;        y_ = powf(1 - t, 2) * origin.y + 2.0f * (1 - t) * t * control.y + t * t * destination.y;                if (i != 0)        ccDrawCircle(previous, _line_thickness * 0.45f, M_PI, 6, false);                ccDrawLine(previous, ccp (x_, y_) );        previous = ccp(x_, y_);                t += (float) 1 / segments;    }}@end